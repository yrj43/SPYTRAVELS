{"version":3,"sources":["../node_modules/three/examples/jsm/loaders/GLTFLoader.js"],"names":["GLTFLoader","manager","call","this","dracoLoader","ddsLoader","GLTFRegistry","objects","get","key","add","object","remove","removeAll","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","resourcePath","scope","path","extractUrlBase","itemStart","_onError","e","console","error","itemError","itemEnd","loader","setPath","setResponseType","crossOrigin","setWithCredentials","data","parse","gltf","setDRACOLoader","setDDSLoader","content","extensions","decodeText","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","json","JSON","undefined","asset","version","Error","extensionsUsed","i","length","extensionName","extensionsRequired","KHR_LIGHTS_PUNCTUAL","GLTFLightsExtension","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","MSFT_TEXTURE_DDS","GLTFTextureDDSExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","indexOf","warn","GLTFParser","name","extension","lightDefs","lights","loadLight","lightIndex","lightNode","lightDef","color","fromArray","range","type","target","position","set","distance","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","intensity","Promise","resolve","getMaterialType","extendParams","materialParams","materialDef","parser","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","push","assignTexture","all","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","BIN","body","headerView","DataView","header","magic","slice","getUint32","chunkView","chunkIndex","byteLength","chunkLength","chunkType","contentArray","byteOffset","specularGlossinessParams","pbrSpecularGlossiness","shader","uniforms","clone","specularMapParsFragmentChunk","join","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","fragmentShader","replace","roughness","metalness","roughnessMap","metalnessMap","specular","value","setHex","glossiness","specularMap","glossinessMap","vertexShader","defines","diffuseFactor","diffuseTexture","emissive","glossinessFactor","specularFactor","specularGlossinessTexture","specGlossMapDef","createMaterial","params","material","fog","transparent","isGLTFSpecularGlossinessMaterial","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalScale","displacementMap","displacementScale","displacementBias","alphaMap","envMap","envMapIntensity","refractionRatio","derivatives","cloneMaterial","source","il","isColor","refreshUniforms","renderer","scene","camera","geometry","uvScaleMap","diffuse","copy","multiplyScalar","isWebGLRenderTarget","texture","matrixAutoUpdate","updateMatrix","uvTransform","matrix","flipEnvMap","isCubeTexture","reflectivity","maxMipLevel","properties","__maxMipLevel","USE_GLOSSINESSMAP","USE_ROUGHNESSMAP","GLTFCubicSplineInterpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","decodePrimitive","primitive","bufferViewIndex","bufferView","gltfAttributeMap","attributes","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","attributeName","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","getDependency","then","decodeDracoFile","attribute","extendTexture","transform","offset","rotation","scale","repeat","texCoord","needsUpdate","copySampleValue_","index","result","values","valueSize","beforeStart_","afterEnd_","interpolate_","i1","t0","t","t1","stride","stride2","stride3","td","p","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","defaultMaterial","WEBGL_CONSTANTS","5120","Int8Array","5121","5122","Int16Array","5123","Uint16Array","5125","Uint32Array","5126","Float32Array","WEBGL_FILTERS","9728","9729","9984","9985","9986","9987","WEBGL_WRAPPINGS","33071","33648","10497","WEBGL_TYPE_SIZES","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","LINEAR","STEP","ALPHA_MODES","MIME_TYPE_FORMATS","resolveURL","test","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","assignExtrasToUserData","gltfDef","extras","updateMorphTargets","mesh","meshDef","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","dracoExtension","indices","createAttributesKey","mode","attributesKey","keys","sort","cloneBufferAttribute","isInterleavedBufferAttribute","count","itemSize","j","getX","getY","getZ","getW","options","cache","primitiveCache","textureLoader","setCrossOrigin","fileLoader","addPrimitiveAttributes","assignAttributeAccessor","accessorIndex","accessor","setAttribute","gltfAttributeName","setIndex","targets","hasMorphPosition","hasMorphNormal","pendingPositionAccessors","pendingNormalAccessors","pendingAccessor","normal","morphPositions","morphNormals","positionAttribute","jl","setXYZ","normalAttribute","morphAttributes","addMorphTargets","markDefs","getDependencies","dependencies","scenes","animations","cameras","catch","nodeDefs","nodes","skinDefs","skins","meshDefs","meshes","meshReferences","meshUses","skinIndex","skinLength","joints","isBone","nodeIndex","nodeLength","nodeDef","skin","isSkinnedMesh","cacheKey","dependency","loadScene","loadNode","loadMesh","loadAccessor","loadBufferView","loadBuffer","loadMaterial","loadTexture","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","buffers","uri","reject","bufferViewDef","bufferViews","buffer","sparse","pendingBufferViews","bufferAttribute","TypedArray","elementBytes","BYTES_PER_ELEMENT","itemBytes","byteStride","ibSlice","floor","ibCacheKey","ib","itemSizeIndices","SCALAR","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","textureIndex","URL","window","webkitURL","textureDef","textures","textureExtensions","sourceURI","images","isObjectURL","blob","Blob","mimeType","createObjectURL","getHandler","revokeObjectURL","flipY","format","sampler","samplers","magFilter","minFilter","wrapS","wrapT","mapName","mapDef","isCompressedTexture","assignFinalMaterial","useVertexTangents","tangent","useVertexColors","useFlatShading","useSkinning","useMorphTargets","useMorphNormals","isPoints","uuid","pointsMaterial","sizeAttenuation","isLine","lineMaterial","cachedMaterial","skinning","vertexTangents","vertexColors","flatShading","morphTargets","uv2","uv","log","onBeforeRender","materialIndex","materialType","materials","materialExtensions","sgExtension","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","side","alphaMode","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","encoding","loadGeometries","primitives","createDracoPrimitive","geometryPromise","cached","promise","meshIndex","depthTest","originalMaterials","geometries","skinWeight","normalizeSkinWeights","drawMode","group","cameraIndex","cameraDef","radToDeg","yfov","aspectRatio","znear","zfar","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","channel","node","id","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","TypedKeyframeTrack","targetName","interpolation","traverse","isMesh","outputArray","scaled","track","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","instanceNum","children","o","light","sanitizeNodeName","applyMatrix","quaternion","buildNodeHierachy","nodeId","parentObject","pendingJoints","jointNodes","bones","boneInverses","jointNode","mat","bind","matrixWorld","child","sceneIndex","sceneDef","nodeIds"],"mappings":"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","file":"static/js/6.2f3ee679.chunk.js","sourcesContent":["/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\nimport { AnimationClip, Bone, BufferAttribute, BufferGeometry, ClampToEdgeWrapping, Color, DirectionalLight, DoubleSide, FileLoader, FrontSide, Group, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, Line, LineBasicMaterial, LineLoop, LineSegments, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, Loader, LoaderUtils, Material, Math as _Math, Matrix4, Mesh, MeshBasicMaterial, MeshStandardMaterial, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NumberKeyframeTrack, Object3D, OrthographicCamera, PerspectiveCamera, PointLight, Points, PointsMaterial, PropertyBinding, QuaternionKeyframeTrack, RGBAFormat, RGBFormat, RepeatWrapping, Scene, ShaderLib, ShaderMaterial, Skeleton, SkinnedMesh, SpotLight, TextureLoader, TriangleFanDrawMode, TriangleStripDrawMode, UniformsUtils, Vector2, VectorKeyframeTrack, VertexColors, sRGBEncoding } from \"../../../build/three.module.js\";\n\nvar GLTFLoader = function () {\n  function GLTFLoader(manager) {\n    Loader.call(this, manager);\n    this.dracoLoader = null;\n    this.ddsLoader = null;\n  }\n\n  GLTFLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: GLTFLoader,\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var resourcePath;\n\n      if (this.resourcePath !== '') {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== '') {\n        resourcePath = this.path;\n      } else {\n        resourcePath = LoaderUtils.extractUrlBase(url);\n      } // Tells the LoadingManager to track an extra item, which resolves after\n      // the model is fully loaded. This means the count of items loaded will\n      // be incorrect, but ensures manager.onLoad() does not fire early.\n\n\n      scope.manager.itemStart(url);\n\n      var _onError = function _onError(e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      };\n\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n\n      if (scope.crossOrigin === 'use-credentials') {\n        loader.setWithCredentials(true);\n      }\n\n      loader.load(url, function (data) {\n        try {\n          scope.parse(data, resourcePath, function (gltf) {\n            onLoad(gltf);\n            scope.manager.itemEnd(url);\n          }, _onError);\n        } catch (e) {\n          _onError(e);\n        }\n      }, onProgress, _onError);\n    },\n    setDRACOLoader: function setDRACOLoader(dracoLoader) {\n      this.dracoLoader = dracoLoader;\n      return this;\n    },\n    setDDSLoader: function setDDSLoader(ddsLoader) {\n      this.ddsLoader = ddsLoader;\n      return this;\n    },\n    parse: function parse(data, path, onLoad, onError) {\n      var content;\n      var extensions = {};\n\n      if (typeof data === 'string') {\n        content = data;\n      } else {\n        var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n          try {\n            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n          } catch (error) {\n            if (onError) onError(error);\n            return;\n          }\n\n          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n        } else {\n          content = LoaderUtils.decodeText(new Uint8Array(data));\n        }\n      }\n\n      var json = JSON.parse(content);\n\n      if (json.asset === undefined || json.asset.version[0] < 2) {\n        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));\n        return;\n      }\n\n      if (json.extensionsUsed) {\n        for (var i = 0; i < json.extensionsUsed.length; ++i) {\n          var extensionName = json.extensionsUsed[i];\n          var extensionsRequired = json.extensionsRequired || [];\n\n          switch (extensionName) {\n            case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n              extensions[extensionName] = new GLTFLightsExtension(json);\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_UNLIT:\n              extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n              break;\n\n            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n              break;\n\n            case EXTENSIONS.MSFT_TEXTURE_DDS:\n              extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);\n              break;\n\n            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n              extensions[extensionName] = new GLTFTextureTransformExtension();\n              break;\n\n            default:\n              if (extensionsRequired.indexOf(extensionName) >= 0) {\n                console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n              }\n\n          }\n        }\n      }\n\n      var parser = new GLTFParser(json, extensions, {\n        path: path || this.resourcePath || '',\n        crossOrigin: this.crossOrigin,\n        manager: this.manager\n      });\n      parser.parse(onLoad, onError);\n    }\n  });\n  /* GLTFREGISTRY */\n\n  function GLTFRegistry() {\n    var objects = {};\n    return {\n      get: function get(key) {\n        return objects[key];\n      },\n      add: function add(key, object) {\n        objects[key] = object;\n      },\n      remove: function remove(key) {\n        delete objects[key];\n      },\n      removeAll: function removeAll() {\n        objects = {};\n      }\n    };\n  }\n  /*********************************/\n\n  /********** EXTENSIONS ***********/\n\n  /*********************************/\n\n\n  var EXTENSIONS = {\n    KHR_BINARY_GLTF: 'KHR_binary_glTF',\n    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n    MSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n  };\n  /**\n   * DDS Texture Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n   *\n   */\n\n  function GLTFTextureDDSExtension(ddsLoader) {\n    if (!ddsLoader) {\n      throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader');\n    }\n\n    this.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n    this.ddsLoader = ddsLoader;\n  }\n  /**\n   * Punctual Lights Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n   */\n\n\n  function GLTFLightsExtension(json) {\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};\n    this.lightDefs = extension.lights || [];\n  }\n\n  GLTFLightsExtension.prototype.loadLight = function (lightIndex) {\n    var lightDef = this.lightDefs[lightIndex];\n    var lightNode;\n    var color = new Color(0xffffff);\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n    var range = lightDef.range !== undefined ? lightDef.range : 0;\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      case 'point':\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n\n      case 'spot':\n        lightNode = new SpotLight(color);\n        lightNode.distance = range; // Handle spotlight properties.\n\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".');\n    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n\n\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n    lightNode.name = lightDef.name || 'light_' + lightIndex;\n    return Promise.resolve(lightNode);\n  };\n  /**\n   * Unlit Materials Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n   */\n\n\n  function GLTFMaterialsUnlitExtension() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n    return MeshBasicMaterial;\n  };\n\n  GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {\n    var pending = [];\n    materialParams.color = new Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    var metallicRoughness = materialDef.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /* BINARY EXTENSION */\n\n\n  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n  var BINARY_EXTENSION_HEADER_LENGTH = 12;\n  var BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 0x4E4F534A,\n    BIN: 0x004E4942\n  };\n\n  function GLTFBinaryExtension(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');\n    }\n\n    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    var chunkIndex = 0;\n\n    while (chunkIndex < chunkView.byteLength) {\n      var chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      var chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      } // Clients must ignore chunks with unknown types.\n\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\n    }\n  }\n  /**\n   * DRACO Mesh Compression Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n   */\n\n\n  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n  }\n\n  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n    var json = this.json;\n    var dracoLoader = this.dracoLoader;\n    var bufferViewIndex = primitive.extensions[this.name].bufferView;\n    var gltfAttributeMap = primitive.extensions[this.name].attributes;\n    var threeAttributeMap = {};\n    var attributeNormalizedMap = {};\n    var attributeTypeMap = {};\n\n    for (var attributeName in gltfAttributeMap) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (attributeName in primitive.attributes) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        var accessorDef = json.accessors[primitive.attributes[attributeName]];\n        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n          for (var attributeName in geometry.attributes) {\n            var attribute = geometry.attributes[attributeName];\n            var normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== undefined) attribute.normalized = normalized;\n          }\n\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  };\n  /**\n   * Texture Transform Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n   */\n\n\n  function GLTFTextureTransformExtension() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {\n    texture = texture.clone();\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset);\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation;\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale);\n    }\n\n    if (transform.texCoord !== undefined) {\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n\n    texture.needsUpdate = true;\n    return texture;\n  };\n  /**\n   * Specular-Glossiness Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n   */\n\n\n  function GLTFMaterialsPbrSpecularGlossinessExtension() {\n    return {\n      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n      specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],\n      getMaterialType: function getMaterialType() {\n        return ShaderMaterial;\n      },\n      extendParams: function extendParams(materialParams, materialDef, parser) {\n        var pbrSpecularGlossiness = materialDef.extensions[this.name];\n        var shader = ShaderLib['standard'];\n        var uniforms = UniformsUtils.clone(shader.uniforms);\n        var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n        var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n        var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n        var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n        var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\\n');\n        var fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n        delete uniforms.roughness;\n        delete uniforms.metalness;\n        delete uniforms.roughnessMap;\n        delete uniforms.metalnessMap;\n        uniforms.specular = {\n          value: new Color().setHex(0x111111)\n        };\n        uniforms.glossiness = {\n          value: 0.5\n        };\n        uniforms.specularMap = {\n          value: null\n        };\n        uniforms.glossinessMap = {\n          value: null\n        };\n        materialParams.vertexShader = shader.vertexShader;\n        materialParams.fragmentShader = fragmentShader;\n        materialParams.uniforms = uniforms;\n        materialParams.defines = {\n          'STANDARD': ''\n        };\n        materialParams.color = new Color(1.0, 1.0, 1.0);\n        materialParams.opacity = 1.0;\n        var pending = [];\n\n        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n          var array = pbrSpecularGlossiness.diffuseFactor;\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n        }\n\n        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n        }\n\n        materialParams.emissive = new Color(0.0, 0.0, 0.0);\n        materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n        materialParams.specular = new Color(1.0, 1.0, 1.0);\n\n        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n          materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n        }\n\n        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n          pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n          pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n        }\n\n        return Promise.all(pending);\n      },\n      createMaterial: function createMaterial(params) {\n        // setup material properties based on MeshStandardMaterial for Specular-Glossiness\n        var material = new ShaderMaterial({\n          defines: params.defines,\n          vertexShader: params.vertexShader,\n          fragmentShader: params.fragmentShader,\n          uniforms: params.uniforms,\n          fog: true,\n          lights: true,\n          opacity: params.opacity,\n          transparent: params.transparent\n        });\n        material.isGLTFSpecularGlossinessMaterial = true;\n        material.color = params.color;\n        material.map = params.map === undefined ? null : params.map;\n        material.lightMap = null;\n        material.lightMapIntensity = 1.0;\n        material.aoMap = params.aoMap === undefined ? null : params.aoMap;\n        material.aoMapIntensity = 1.0;\n        material.emissive = params.emissive;\n        material.emissiveIntensity = 1.0;\n        material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n        material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n        material.bumpScale = 1;\n        material.normalMap = params.normalMap === undefined ? null : params.normalMap;\n        if (params.normalScale) material.normalScale = params.normalScale;\n        material.displacementMap = null;\n        material.displacementScale = 1;\n        material.displacementBias = 0;\n        material.specularMap = params.specularMap === undefined ? null : params.specularMap;\n        material.specular = params.specular;\n        material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n        material.glossiness = params.glossiness;\n        material.alphaMap = null;\n        material.envMap = params.envMap === undefined ? null : params.envMap;\n        material.envMapIntensity = 1.0;\n        material.refractionRatio = 0.98;\n        material.extensions.derivatives = true;\n        return material;\n      },\n\n      /**\n       * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n       * copy only properties it knows about or inherits, and misses many properties that would\n       * normally be defined by MeshStandardMaterial.\n       *\n       * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n       * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n       * AND also updating `.onBeforeRender` on the parent mesh.\n       *\n       * @param  {ShaderMaterial} source\n       * @return {ShaderMaterial}\n       */\n      cloneMaterial: function cloneMaterial(source) {\n        var target = source.clone();\n        target.isGLTFSpecularGlossinessMaterial = true;\n        var params = this.specularGlossinessParams;\n\n        for (var i = 0, il = params.length; i < il; i++) {\n          var value = source[params[i]];\n          target[params[i]] = value && value.isColor ? value.clone() : value;\n        }\n\n        return target;\n      },\n      // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n      refreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material) {\n        if (material.isGLTFSpecularGlossinessMaterial !== true) {\n          return;\n        }\n\n        var uniforms = material.uniforms;\n        var defines = material.defines;\n        uniforms.opacity.value = material.opacity;\n        uniforms.diffuse.value.copy(material.color);\n        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n        uniforms.map.value = material.map;\n        uniforms.specularMap.value = material.specularMap;\n        uniforms.alphaMap.value = material.alphaMap;\n        uniforms.lightMap.value = material.lightMap;\n        uniforms.lightMapIntensity.value = material.lightMapIntensity;\n        uniforms.aoMap.value = material.aoMap;\n        uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities\n        // 1. color map\n        // 2. specular map\n        // 3. normal map\n        // 4. bump map\n        // 5. alpha map\n        // 6. emissive map\n\n        var uvScaleMap;\n\n        if (material.map) {\n          uvScaleMap = material.map;\n        } else if (material.specularMap) {\n          uvScaleMap = material.specularMap;\n        } else if (material.displacementMap) {\n          uvScaleMap = material.displacementMap;\n        } else if (material.normalMap) {\n          uvScaleMap = material.normalMap;\n        } else if (material.bumpMap) {\n          uvScaleMap = material.bumpMap;\n        } else if (material.glossinessMap) {\n          uvScaleMap = material.glossinessMap;\n        } else if (material.alphaMap) {\n          uvScaleMap = material.alphaMap;\n        } else if (material.emissiveMap) {\n          uvScaleMap = material.emissiveMap;\n        }\n\n        if (uvScaleMap !== undefined) {\n          // backwards compatibility\n          if (uvScaleMap.isWebGLRenderTarget) {\n            uvScaleMap = uvScaleMap.texture;\n          }\n\n          if (uvScaleMap.matrixAutoUpdate === true) {\n            uvScaleMap.updateMatrix();\n          }\n\n          uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n        }\n\n        if (material.envMap) {\n          uniforms.envMap.value = material.envMap;\n          uniforms.envMapIntensity.value = material.envMapIntensity; // don't flip CubeTexture envMaps, flip everything else:\n          //  WebGLRenderTargetCube will be flipped for backwards compatibility\n          //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n          // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\n          uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;\n          uniforms.reflectivity.value = material.reflectivity;\n          uniforms.refractionRatio.value = material.refractionRatio;\n          uniforms.maxMipLevel.value = renderer.properties.get(material.envMap).__maxMipLevel;\n        }\n\n        uniforms.specular.value.copy(material.specular);\n        uniforms.glossiness.value = material.glossiness;\n        uniforms.glossinessMap.value = material.glossinessMap;\n        uniforms.emissiveMap.value = material.emissiveMap;\n        uniforms.bumpMap.value = material.bumpMap;\n        uniforms.normalMap.value = material.normalMap;\n        uniforms.displacementMap.value = material.displacementMap;\n        uniforms.displacementScale.value = material.displacementScale;\n        uniforms.displacementBias.value = material.displacementBias;\n\n        if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {\n          defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv\n\n          defines.USE_ROUGHNESSMAP = '';\n        }\n\n        if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {\n          delete defines.USE_GLOSSINESSMAP;\n          delete defines.USE_ROUGHNESSMAP;\n        }\n      }\n    };\n  }\n  /*********************************/\n\n  /********** INTERPOLATION ********/\n\n  /*********************************/\n  // Spline Interpolation\n  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\n  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  GLTFCubicSplineInterpolant.prototype = Object.create(Interpolant.prototype);\n  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n  GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n    var result = this.resultBuffer,\n        values = this.sampleValues,\n        valueSize = this.valueSize,\n        offset = index * valueSize * 3 + valueSize;\n\n    for (var i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  };\n\n  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n    var result = this.resultBuffer;\n    var values = this.sampleValues;\n    var stride = this.valueSize;\n    var stride2 = stride * 2;\n    var stride3 = stride * 3;\n    var td = t1 - t0;\n    var p = (t - t0) / td;\n    var pp = p * p;\n    var ppp = pp * p;\n    var offset1 = i1 * stride3;\n    var offset0 = offset1 - stride3;\n    var s2 = -2 * ppp + 3 * pp;\n    var s3 = ppp - pp;\n    var s0 = 1 - s2;\n    var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n    for (var i = 0; i !== stride; i++) {\n      var p0 = values[offset0 + i + stride]; // splineVertex_k\n\n      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n      var p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n\n    return result;\n  };\n  /*********************************/\n\n  /********** INTERNALS ************/\n\n  /*********************************/\n\n  /* CONSTANTS */\n\n\n  var WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n  };\n  var WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n  };\n  var WEBGL_FILTERS = {\n    9728: NearestFilter,\n    9729: LinearFilter,\n    9984: NearestMipmapNearestFilter,\n    9985: LinearMipmapNearestFilter,\n    9986: NearestMipmapLinearFilter,\n    9987: LinearMipmapLinearFilter\n  };\n  var WEBGL_WRAPPINGS = {\n    33071: ClampToEdgeWrapping,\n    33648: MirroredRepeatWrapping,\n    10497: RepeatWrapping\n  };\n  var WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n  };\n  var ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex'\n  };\n  var PATH_PROPERTIES = {\n    scale: 'scale',\n    translation: 'position',\n    rotation: 'quaternion',\n    weights: 'morphTargetInfluences'\n  };\n  var INTERPOLATION = {\n    CUBICSPLINE: undefined,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: InterpolateLinear,\n    STEP: InterpolateDiscrete\n  };\n  var ALPHA_MODES = {\n    OPAQUE: 'OPAQUE',\n    MASK: 'MASK',\n    BLEND: 'BLEND'\n  };\n  var MIME_TYPE_FORMATS = {\n    'image/png': RGBAFormat,\n    'image/jpeg': RGBFormat\n  };\n  /* UTILITY FUNCTIONS */\n\n  function resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return ''; // Host Relative URL\n\n    if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n      path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n    } // Absolute URL http://,https://,//\n\n\n    if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n    if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n    return path + url;\n  }\n\n  var defaultMaterial;\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n   */\n\n  function createDefaultMaterial() {\n    defaultMaterial = defaultMaterial || new MeshStandardMaterial({\n      color: 0xFFFFFF,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide\n    });\n    return defaultMaterial;\n  }\n\n  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    // Add unknown glTF extensions to an object's userData.\n    for (var name in objectDef.extensions) {\n      if (knownExtensions[name] === undefined) {\n        object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n        object.userData.gltfExtensions[name] = objectDef.extensions[name];\n      }\n    }\n  }\n  /**\n   * @param {Object3D|Material|BufferGeometry} object\n   * @param {GLTF.definition} gltfDef\n   */\n\n\n  function assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== undefined) {\n      if (typeof gltfDef.extras === 'object') {\n        Object.assign(object.userData, gltfDef.extras);\n      } else {\n        console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n      }\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n   *\n   * @param {BufferGeometry} geometry\n   * @param {Array<GLTF.Target>} targets\n   * @param {GLTFParser} parser\n   * @return {Promise<BufferGeometry>}\n   */\n\n\n  function addMorphTargets(geometry, targets, parser) {\n    var hasMorphPosition = false;\n    var hasMorphNormal = false;\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n      if (target.POSITION !== undefined) hasMorphPosition = true;\n      if (target.NORMAL !== undefined) hasMorphNormal = true;\n      if (hasMorphPosition && hasMorphNormal) break;\n    }\n\n    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n    var pendingPositionAccessors = [];\n    var pendingNormalAccessors = [];\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n\n      if (hasMorphPosition) {\n        var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n        pendingPositionAccessors.push(pendingAccessor);\n      }\n\n      if (hasMorphNormal) {\n        var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n        pendingNormalAccessors.push(pendingAccessor);\n      }\n    }\n\n    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\n      var morphPositions = accessors[0];\n      var morphNormals = accessors[1]; // Clone morph target accessors before modifying them.\n\n      for (var i = 0, il = morphPositions.length; i < il; i++) {\n        if (geometry.attributes.position === morphPositions[i]) continue;\n        morphPositions[i] = cloneBufferAttribute(morphPositions[i]);\n      }\n\n      for (var i = 0, il = morphNormals.length; i < il; i++) {\n        if (geometry.attributes.normal === morphNormals[i]) continue;\n        morphNormals[i] = cloneBufferAttribute(morphNormals[i]);\n      }\n\n      for (var i = 0, il = targets.length; i < il; i++) {\n        var target = targets[i];\n        var attributeName = 'morphTarget' + i;\n\n        if (hasMorphPosition) {\n          // Three.js morph position is absolute value. The formula is\n          //   basePosition\n          //     + weight0 * ( morphPosition0 - basePosition )\n          //     + weight1 * ( morphPosition1 - basePosition )\n          //     ...\n          // while the glTF one is relative\n          //   basePosition\n          //     + weight0 * glTFmorphPosition0\n          //     + weight1 * glTFmorphPosition1\n          //     ...\n          // then we need to convert from relative to absolute here.\n          if (target.POSITION !== undefined) {\n            var positionAttribute = morphPositions[i];\n            positionAttribute.name = attributeName;\n            var position = geometry.attributes.position;\n\n            for (var j = 0, jl = positionAttribute.count; j < jl; j++) {\n              positionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));\n            }\n          }\n        }\n\n        if (hasMorphNormal) {\n          // see target.POSITION's comment\n          if (target.NORMAL !== undefined) {\n            var normalAttribute = morphNormals[i];\n            normalAttribute.name = attributeName;\n            var normal = geometry.attributes.normal;\n\n            for (var j = 0, jl = normalAttribute.count; j < jl; j++) {\n              normalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));\n            }\n          }\n        }\n      }\n\n      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n      return geometry;\n    });\n  }\n  /**\n   * @param {Mesh} mesh\n   * @param {GLTF.Mesh} meshDef\n   */\n\n\n  function updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n\n    if (meshDef.weights !== undefined) {\n      for (var i = 0, il = meshDef.weights.length; i < il; i++) {\n        mesh.morphTargetInfluences[i] = meshDef.weights[i];\n      }\n    } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n      var targetNames = meshDef.extras.targetNames;\n\n      if (mesh.morphTargetInfluences.length === targetNames.length) {\n        mesh.morphTargetDictionary = {};\n\n        for (var i = 0, il = targetNames.length; i < il; i++) {\n          mesh.morphTargetDictionary[targetNames[i]] = i;\n        }\n      } else {\n        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n      }\n    }\n  }\n\n  function createPrimitiveKey(primitiveDef) {\n    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    var geometryKey;\n\n    if (dracoExtension) {\n      geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n    } else {\n      geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n    }\n\n    return geometryKey;\n  }\n\n  function createAttributesKey(attributes) {\n    var attributesKey = '';\n    var keys = Object.keys(attributes).sort();\n\n    for (var i = 0, il = keys.length; i < il; i++) {\n      attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n    }\n\n    return attributesKey;\n  }\n\n  function cloneBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) {\n      var count = attribute.count;\n      var itemSize = attribute.itemSize;\n      var array = attribute.array.slice(0, count * itemSize);\n\n      for (var i = 0, j = 0; i < count; ++i) {\n        array[j++] = attribute.getX(i);\n        if (itemSize >= 2) array[j++] = attribute.getY(i);\n        if (itemSize >= 3) array[j++] = attribute.getZ(i);\n        if (itemSize >= 4) array[j++] = attribute.getW(i);\n      }\n\n      return new BufferAttribute(array, itemSize, attribute.normalized);\n    }\n\n    return attribute.clone();\n  }\n  /* GLTF PARSER */\n\n\n  function GLTFParser(json, extensions, options) {\n    this.json = json || {};\n    this.extensions = extensions || {};\n    this.options = options || {}; // loader object cache\n\n    this.cache = new GLTFRegistry(); // BufferGeometry caching\n\n    this.primitiveCache = {};\n    this.textureLoader = new TextureLoader(this.options.manager);\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n\n  GLTFParser.prototype.parse = function (onLoad, onError) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions; // Clear the loader cache\n\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n    this.markDefs();\n    Promise.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {\n      var result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser: parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      onLoad(result);\n    }).catch(onError);\n  };\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n\n\n  GLTFParser.prototype.markDefs = function () {\n    var nodeDefs = this.json.nodes || [];\n    var skinDefs = this.json.skins || [];\n    var meshDefs = this.json.meshes || [];\n    var meshReferences = {};\n    var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n\n    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      var joints = skinDefs[skinIndex].joints;\n\n      for (var i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n    // avoid having more than one Mesh with the same name, count\n    // references and rename instances below.\n    //\n    // Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\n\n    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      var nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        if (meshReferences[nodeDef.mesh] === undefined) {\n          meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n        }\n\n        meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n    }\n\n    this.json.meshReferences = meshReferences;\n    this.json.meshUses = meshUses;\n  };\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n\n\n  GLTFParser.prototype.getDependency = function (type, index) {\n    var cacheKey = type + ':' + index;\n    var dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this.loadMesh(index);\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this.loadBufferView(index);\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this.loadMaterial(index);\n          break;\n\n        case 'texture':\n          dependency = this.loadTexture(index);\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this.loadAnimation(index);\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        case 'light':\n          dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  };\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  GLTFParser.prototype.getDependencies = function (type) {\n    var dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      var parser = this;\n      var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBuffer = function (bufferIndex) {\n    var bufferDef = this.json.buffers[bufferIndex];\n    var loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n    } // If present, GLB container is required to be the first buffer.\n\n\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    var options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n    var bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      var byteLength = bufferViewDef.byteLength || 0;\n      var byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n\n\n  GLTFParser.prototype.loadAccessor = function (accessorIndex) {\n    var parser = this;\n    var json = this.json;\n    var accessorDef = this.json.accessors[accessorIndex];\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return Promise.resolve(null);\n    }\n\n    var pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      var bufferView = bufferViews[0];\n      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n      var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      var itemBytes = elementBytes * itemSize;\n      var byteOffset = accessorDef.byteOffset || 0;\n      var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n      var normalized = accessorDef.normalized === true;\n      var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        var ibSlice = Math.floor(byteOffset / byteStride);\n        var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n        var ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n      if (accessorDef.sparse !== undefined) {\n        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n\n        for (var i = 0, il = sparseIndices.length; i < il; i++) {\n          var index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n        }\n      }\n\n      return bufferAttribute;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  GLTFParser.prototype.loadTexture = function (textureIndex) {\n    var parser = this;\n    var json = this.json;\n    var options = this.options;\n    var textureLoader = this.textureLoader;\n    var URL = window.URL || window.webkitURL;\n    var textureDef = json.textures[textureIndex];\n    var textureExtensions = textureDef.extensions || {};\n    var source;\n\n    if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n      source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n    } else {\n      source = json.images[textureDef.source];\n    }\n\n    var sourceURI = source.uri;\n    var isObjectURL = false;\n\n    if (source.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n        isObjectURL = true;\n        var blob = new Blob([bufferView], {\n          type: source.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    }\n\n    return Promise.resolve(sourceURI).then(function (sourceURI) {\n      // Load Texture resource.\n      var loader = options.manager.getHandler(sourceURI);\n\n      if (!loader) {\n        loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;\n      }\n\n      return new Promise(function (resolve, reject) {\n        loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n      });\n    }).then(function (texture) {\n      // Clean up resources and configure Texture.\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n\n      texture.flipY = false;\n      if (textureDef.name !== undefined) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files.\n\n      if (source.mimeType in MIME_TYPE_FORMATS) {\n        texture.format = MIME_TYPE_FORMATS[source.mimeType];\n      }\n\n      var samplers = json.samplers || {};\n      var sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      return texture;\n    });\n  };\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise}\n   */\n\n\n  GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {\n    var parser = this;\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture.isCompressedTexture) {\n        switch (mapName) {\n          case 'aoMap':\n          case 'emissiveMap':\n          case 'metalnessMap':\n          case 'normalMap':\n          case 'roughnessMap':\n            texture.format = RGBFormat;\n            break;\n        }\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n        if (transform) {\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n        }\n      }\n\n      materialParams[mapName] = texture;\n    });\n  };\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accomodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n\n\n  GLTFParser.prototype.assignFinalMaterial = function (mesh) {\n    var geometry = mesh.geometry;\n    var material = mesh.material;\n    var extensions = this.extensions;\n    var useVertexTangents = geometry.attributes.tangent !== undefined;\n    var useVertexColors = geometry.attributes.color !== undefined;\n    var useFlatShading = geometry.attributes.normal === undefined;\n    var useSkinning = mesh.isSkinnedMesh === true;\n    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\n    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n    if (mesh.isPoints) {\n      var cacheKey = 'PointsMaterial:' + material.uuid;\n      var pointsMaterial = this.cache.get(cacheKey);\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      var cacheKey = 'LineBasicMaterial:' + material.uuid;\n      var lineMaterial = this.cache.get(cacheKey);\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        this.cache.add(cacheKey, lineMaterial);\n      }\n\n      material = lineMaterial;\n    } // Clone the material if it will be modified\n\n\n    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n      var cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n      if (useSkinning) cacheKey += 'skinning:';\n      if (useVertexTangents) cacheKey += 'vertex-tangents:';\n      if (useVertexColors) cacheKey += 'vertex-colors:';\n      if (useFlatShading) cacheKey += 'flat-shading:';\n      if (useMorphTargets) cacheKey += 'morph-targets:';\n      if (useMorphNormals) cacheKey += 'morph-normals:';\n      var cachedMaterial = this.cache.get(cacheKey);\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material) : material.clone();\n        if (useSkinning) cachedMaterial.skinning = true;\n        if (useVertexTangents) cachedMaterial.vertexTangents = true;\n        if (useVertexColors) cachedMaterial.vertexColors = VertexColors;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n        if (useMorphTargets) cachedMaterial.morphTargets = true;\n        if (useMorphNormals) cachedMaterial.morphNormals = true;\n        this.cache.add(cacheKey, cachedMaterial);\n      }\n\n      material = cachedMaterial;\n    } // workarounds for mesh and geometry\n\n\n    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n      console.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');\n      geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n    }\n\n    if (material.isGLTFSpecularGlossinessMaterial) {\n      // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update\n      mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;\n    }\n\n    mesh.material = material;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n\n\n  GLTFParser.prototype.loadMaterial = function (materialIndex) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions;\n    var materialDef = json.materials[materialIndex];\n    var materialType;\n    var materialParams = {};\n    var materialExtensions = materialDef.extensions || {};\n    var pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n      materialType = MeshStandardMaterial;\n      var metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n      }\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n\n    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n    } else {\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));\n      materialParams.normalScale = new Vector2(1, 1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n    }\n\n    return Promise.all(pending).then(function () {\n      var material;\n\n      if (materialType === ShaderMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name !== undefined) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\n      if (material.map) material.map.encoding = sRGBEncoding;\n      if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;\n      if (material.specularMap) material.specularMap.encoding = sRGBEncoding;\n      assignExtrasToUserData(material, materialDef);\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  };\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {GLTF.Primitive} primitiveDef\n   * @param {GLTFParser} parser\n   * @return {Promise<BufferGeometry>}\n   */\n\n\n  function addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    var attributes = primitiveDef.attributes;\n    var pending = [];\n\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n      return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n        geometry.setAttribute(attributeName, accessor);\n      });\n    }\n\n    for (var gltfAttributeName in attributes) {\n      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n      if (threeAttributeName in geometry.attributes) continue;\n      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n\n    if (primitiveDef.indices !== undefined && !geometry.index) {\n      var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n        geometry.setIndex(accessor);\n      });\n      pending.push(accessor);\n    }\n\n    assignExtrasToUserData(geometry, primitiveDef);\n    return Promise.all(pending).then(function () {\n      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n\n\n  GLTFParser.prototype.loadGeometries = function (primitives) {\n    var parser = this;\n    var extensions = this.extensions;\n    var cache = this.primitiveCache;\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var primitive = primitives[i];\n      var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n      var cached = cache[cacheKey];\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise);\n      } else {\n        var geometryPromise;\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        } // Cache this geometry\n\n\n        cache[cacheKey] = {\n          primitive: primitive,\n          promise: geometryPromise\n        };\n        pending.push(geometryPromise);\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n\n\n  GLTFParser.prototype.loadMesh = function (meshIndex) {\n    var parser = this;\n    var json = this.json;\n    var meshDef = json.meshes[meshIndex];\n    var primitives = meshDef.primitives;\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var material = primitives[i].material === undefined ? createDefaultMaterial() : this.getDependency('material', primitives[i].material);\n      pending.push(material);\n    }\n\n    return Promise.all(pending).then(function (originalMaterials) {\n      return parser.loadGeometries(primitives).then(function (geometries) {\n        var meshes = [];\n\n        for (var i = 0, il = geometries.length; i < il; i++) {\n          var geometry = geometries[i];\n          var primitive = primitives[i]; // 1. create Mesh\n\n          var mesh;\n          var material = originalMaterials[i];\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n            // .isSkinnedMesh isn't in glTF spec. See .markDefs()\n            mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n\n            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n              // we normalize floating point skin weight array to fix malformed assets (see #15319)\n              // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n              mesh.normalizeSkinWeights();\n            }\n\n            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n              mesh.drawMode = TriangleStripDrawMode;\n            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n              mesh.drawMode = TriangleFanDrawMode;\n            }\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n            mesh = new LineSegments(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n            mesh = new Line(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n            mesh = new LineLoop(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n            mesh = new Points(geometry, material);\n          } else {\n            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n          }\n\n          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n            updateMorphTargets(mesh, meshDef);\n          }\n\n          mesh.name = meshDef.name || 'mesh_' + meshIndex;\n          if (geometries.length > 1) mesh.name += '_' + i;\n          assignExtrasToUserData(mesh, meshDef);\n          parser.assignFinalMaterial(mesh);\n          meshes.push(mesh);\n        }\n\n        if (meshes.length === 1) {\n          return meshes[0];\n        }\n\n        var group = new Group();\n\n        for (var i = 0, il = meshes.length; i < il; i++) {\n          group.add(meshes[i]);\n        }\n\n        return group;\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n\n\n  GLTFParser.prototype.loadCamera = function (cameraIndex) {\n    var camera;\n    var cameraDef = this.json.cameras[cameraIndex];\n    var params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(_Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);\n    }\n\n    if (cameraDef.name !== undefined) camera.name = cameraDef.name;\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n\n\n  GLTFParser.prototype.loadSkin = function (skinIndex) {\n    var skinDef = this.json.skins[skinIndex];\n    var skinEntry = {\n      joints: skinDef.joints\n    };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n\n\n  GLTFParser.prototype.loadAnimation = function (animationIndex) {\n    var json = this.json;\n    var animationDef = json.animations[animationIndex];\n    var pendingNodes = [];\n    var pendingInputAccessors = [];\n    var pendingOutputAccessors = [];\n    var pendingSamplers = [];\n    var pendingTargets = [];\n\n    for (var i = 0, il = animationDef.channels.length; i < il; i++) {\n      var channel = animationDef.channels[i];\n      var sampler = animationDef.samplers[channel.sampler];\n      var target = channel.target;\n      var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n      var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n      var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency('node', name));\n      pendingInputAccessors.push(this.getDependency('accessor', input));\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n      var nodes = dependencies[0];\n      var inputAccessors = dependencies[1];\n      var outputAccessors = dependencies[2];\n      var samplers = dependencies[3];\n      var targets = dependencies[4];\n      var tracks = [];\n\n      for (var i = 0, il = nodes.length; i < il; i++) {\n        var node = nodes[i];\n        var inputAccessor = inputAccessors[i];\n        var outputAccessor = outputAccessors[i];\n        var sampler = samplers[i];\n        var target = targets[i];\n        if (node === undefined) continue;\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n        var TypedKeyframeTrack;\n\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = QuaternionKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n\n        var targetName = node.name ? node.name : node.uuid;\n        var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n        var targetNames = [];\n\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          // Node may be a Group (glTF mesh with several primitives) or a Mesh.\n          node.traverse(function (object) {\n            if (object.isMesh === true && object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n\n        var outputArray = outputAccessor.array;\n\n        if (outputAccessor.normalized) {\n          var scale;\n\n          if (outputArray.constructor === Int8Array) {\n            scale = 1 / 127;\n          } else if (outputArray.constructor === Uint8Array) {\n            scale = 1 / 255;\n          } else if (outputArray.constructor == Int16Array) {\n            scale = 1 / 32767;\n          } else if (outputArray.constructor === Uint16Array) {\n            scale = 1 / 65535;\n          } else {\n            throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.');\n          }\n\n          var scaled = new Float32Array(outputArray.length);\n\n          for (var j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n\n          outputArray = scaled;\n        }\n\n        for (var j = 0, jl = targetNames.length; j < jl; j++) {\n          var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\n\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n\n          tracks.push(track);\n        }\n      }\n\n      var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n      return new AnimationClip(name, undefined, tracks);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n\n\n  GLTFParser.prototype.loadNode = function (nodeIndex) {\n    var json = this.json;\n    var extensions = this.extensions;\n    var parser = this;\n    var meshReferences = json.meshReferences;\n    var meshUses = json.meshUses;\n    var nodeDef = json.nodes[nodeIndex];\n    return function () {\n      var pending = [];\n\n      if (nodeDef.mesh !== undefined) {\n        pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n          var node;\n\n          if (meshReferences[nodeDef.mesh] > 1) {\n            var instanceNum = meshUses[nodeDef.mesh]++;\n            node = mesh.clone();\n            node.name += '_instance_' + instanceNum; // onBeforeRender copy for Specular-Glossiness\n\n            node.onBeforeRender = mesh.onBeforeRender;\n\n            for (var i = 0, il = node.children.length; i < il; i++) {\n              node.children[i].name += '_instance_' + instanceNum;\n              node.children[i].onBeforeRender = mesh.children[i].onBeforeRender;\n            }\n          } else {\n            node = mesh;\n          } // if weights are provided on the node, override weights on the mesh.\n\n\n          if (nodeDef.weights !== undefined) {\n            node.traverse(function (o) {\n              if (!o.isMesh) return;\n\n              for (var i = 0, il = nodeDef.weights.length; i < il; i++) {\n                o.morphTargetInfluences[i] = nodeDef.weights[i];\n              }\n            });\n          }\n\n          return node;\n        }));\n      }\n\n      if (nodeDef.camera !== undefined) {\n        pending.push(parser.getDependency('camera', nodeDef.camera));\n      }\n\n      if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {\n        pending.push(parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));\n      }\n\n      return Promise.all(pending);\n    }().then(function (objects) {\n      var node; // .isBone isn't in glTF spec. See .markDefs\n\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n\n      if (node !== objects[0]) {\n        for (var i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n\n      if (nodeDef.name !== undefined) {\n        node.userData.name = nodeDef.name;\n        node.name = PropertyBinding.sanitizeNodeName(nodeDef.name);\n      }\n\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n      if (nodeDef.matrix !== undefined) {\n        var matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      return node;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Scene>}\n   */\n\n\n  GLTFParser.prototype.loadScene = function () {\n    // scene node hierachy builder\n    function buildNodeHierachy(nodeId, parentObject, json, parser) {\n      var nodeDef = json.nodes[nodeId];\n      return parser.getDependency('node', nodeId).then(function (node) {\n        if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n        var skinEntry;\n        return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n          skinEntry = skin;\n          var pendingJoints = [];\n\n          for (var i = 0, il = skinEntry.joints.length; i < il; i++) {\n            pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n          }\n\n          return Promise.all(pendingJoints);\n        }).then(function (jointNodes) {\n          node.traverse(function (mesh) {\n            if (!mesh.isMesh) return;\n            var bones = [];\n            var boneInverses = [];\n\n            for (var j = 0, jl = jointNodes.length; j < jl; j++) {\n              var jointNode = jointNodes[j];\n\n              if (jointNode) {\n                bones.push(jointNode);\n                var mat = new Matrix4();\n\n                if (skinEntry.inverseBindMatrices !== undefined) {\n                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n                }\n\n                boneInverses.push(mat);\n              } else {\n                console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n              }\n            }\n\n            mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);\n          });\n          return node;\n        });\n      }).then(function (node) {\n        // build node hierachy\n        parentObject.add(node);\n        var pending = [];\n\n        if (nodeDef.children) {\n          var children = nodeDef.children;\n\n          for (var i = 0, il = children.length; i < il; i++) {\n            var child = children[i];\n            pending.push(buildNodeHierachy(child, node, json, parser));\n          }\n        }\n\n        return Promise.all(pending);\n      });\n    }\n\n    return function loadScene(sceneIndex) {\n      var json = this.json;\n      var extensions = this.extensions;\n      var sceneDef = this.json.scenes[sceneIndex];\n      var parser = this;\n      var scene = new Scene();\n      if (sceneDef.name !== undefined) scene.name = sceneDef.name;\n      assignExtrasToUserData(scene, sceneDef);\n      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n      var nodeIds = sceneDef.nodes || [];\n      var pending = [];\n\n      for (var i = 0, il = nodeIds.length; i < il; i++) {\n        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n      }\n\n      return Promise.all(pending).then(function () {\n        return scene;\n      });\n    };\n  }();\n\n  return GLTFLoader;\n}();\n\nexport { GLTFLoader };"],"sourceRoot":""}
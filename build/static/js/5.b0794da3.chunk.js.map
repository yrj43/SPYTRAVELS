{"version":3,"sources":["utils/three.js","components/Globe.js"],"names":["clean","scene","traverse","object","isMesh","geometry","dispose","material","isMaterial","cleanMaterial","Object","keys","value","returnSphericalCoordinates","latitude","longitude","size","radius","width","height","outputRadius","Math","cos","PI","x","y","sin","z","Globe","globeRadius","mapSize","colours","alphas","status","collapsed","props","viewportSize","useViewportSize","canvasRef","useRef","sceneRef","rendererRef","globeElementRef","animationFrameRef","initViewportSize","globeColors","useContext","ThemeContext","cameraRef","controls","angles","current","azimuthal","polar","groupsRef","main","globe","globeDots","animationsRef","dots","total","points","useEffect","canvas","Scene","WebGLRenderer","antialias","alpha","shadowMapEnabled","setSize","setPixelRatio","setClearColor","PerspectiveCamera","position","OrbitControls","enableKeys","enablePan","enableZoom","enableDamping","enableRotate","autoRotate","autoRotateSpeed","Group","name","add","TextureLoader","setCrossOrigin","textureCanvas","document","createElement","canvasContext","getContext","rect","canvasGradient","createLinearGradient","addColorStop","fillStyle","fill","texture","Texture","needsUpdate","SphereGeometry","MeshBasicMaterial","map","transparent","opacity","Mesh","rotation","Geometry","beginPath","arc","canvasSize","PointsMaterial","addDot","point","Vector3","vertices","push","result","i","globeData","length","country","countries","Points","addGlobeDots","addGlobe","animate","requestAnimationFrame","totalLength","dotProgress","easeInOutCubic","verticesNeedUpdate","globeProgress","easeOutCubic","introAnimate","update","render","remove","cancelAnimationFrame","domElement","forceContextLoss","aspect","updateProjectionMatrix","GlobeContainer","GlobeCanvas","ref","defaultProps","lines","t","styled","div","attrs","style","transform","theme","curveFastoutSlowin"],"mappings":"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","file":"static/js/5.b0794da3.chunk.js","sourcesContent":["export const clean = scene => {\n  scene.traverse(object => {\n    if (!object.isMesh) return;\n\n    object.geometry.dispose();\n\n    if (object.material.isMaterial) {\n      cleanMaterial(object.material);\n    } else {\n      // an array of materials\n      for (const material of object.material) cleanMaterial(material);\n    }\n  });\n};\n\nconst cleanMaterial = material => {\n  material.dispose();\n\n  // dispose textures\n  for (const key of Object.keys(material)) {\n    const value = material[key];\n    if (value && typeof value === 'object' && 'minFilter' in value) {\n      value.dispose();\n    }\n  }\n};\n\nexport const returnSphericalCoordinates = (latitude, longitude, size, radius) => {\n  latitude = ((latitude - size.width) / size.width) * -180;\n  longitude = ((longitude - size.height) / size.height) * -90;\n\n  const outputRadius = Math.cos(longitude / 180 * Math.PI) * radius;\n  const x = Math.cos(latitude / 180 * Math.PI) * outputRadius;\n  const y = Math.sin(longitude / 180 * Math.PI) * radius;\n  const z = Math.sin(latitude / 180 * Math.PI) * outputRadius;\n\n  return { x, y, z };\n};\n","import React, { useRef, useEffect, useContext } from 'react';\nimport styled, { ThemeContext } from 'styled-components/macro';\nimport {\n  WebGLRenderer,\n  PerspectiveCamera,\n  Scene,\n  Group,\n  Texture,\n  TextureLoader,\n  Mesh,\n  MeshBasicMaterial,\n  Points,\n  PointsMaterial,\n  Vector3,\n  Geometry,\n  SphereGeometry,\n} from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport globeData from 'data/globe';\nimport { useViewportSize } from 'hooks';\nimport { clean, returnSphericalCoordinates } from 'utils/three';\n\nfunction Globe({ globeRadius, mapSize, colours, alphas, status, collapsed, ...props }) {\n  const viewportSize = useViewportSize();\n  const canvasRef = useRef();\n  const sceneRef = useRef();\n  const rendererRef = useRef();\n  const globeElementRef = useRef();\n  const animationFrameRef = useRef();\n  const initViewportSize = useRef(viewportSize);\n  const { globeColors } = useContext(ThemeContext);\n\n  const cameraRef = useRef({\n    object: null,\n    controls: null,\n    angles: {\n      current: {\n        azimuthal: null,\n        polar: null,\n      },\n    }\n  });\n\n  const groupsRef = useRef({\n    main: null,\n    globe: null,\n    globeDots: null,\n  });\n\n  const animationsRef = useRef({\n    dots: {\n      current: 0,\n      total: 170,\n      points: [],\n    },\n    globe: {\n      current: 0,\n      total: 80,\n    },\n  });\n\n  useEffect(() => {\n    const { width, height } = initViewportSize.current;\n    const canvas = canvasRef.current;\n\n    sceneRef.current = new Scene();\n    rendererRef.current = new WebGLRenderer({\n      canvas: canvas,\n      antialias: true,\n      alpha: true,\n      shadowMapEnabled: false,\n    });\n\n    rendererRef.current.setSize(width, (height / 2));\n    rendererRef.current.setPixelRatio(2);\n    rendererRef.current.setClearColor(0x000000, 0);\n    cameraRef.current.object = new PerspectiveCamera(60, width / (height / 2), 1, 10000);\n    cameraRef.current.object.position.z = globeRadius * 2.2;\n    cameraRef.current.controls = new OrbitControls(cameraRef.current.object, canvas);\n    cameraRef.current.controls.enableKeys = false;\n    cameraRef.current.controls.enablePan = false;\n    cameraRef.current.controls.enableZoom = false;\n    cameraRef.current.controls.enableDamping = true;\n    cameraRef.current.controls.enableRotate = true;\n    cameraRef.current.controls.autoRotate = true;\n    cameraRef.current.controls.autoRotateSpeed = 0.5;\n    cameraRef.current.angles.current.azimuthal = -Math.PI;\n    cameraRef.current.angles.current.polar = 0;\n    groupsRef.current.main = new Group();\n    groupsRef.current.main.name = 'Main';\n    sceneRef.current.add(groupsRef.current.main);\n\n    const introAnimate = () => {\n      const { dots, globe } = animationsRef.current;\n\n      if (dots.current <= dots.total) {\n        const points = groupsRef.current.globeDots.geometry.vertices;\n        const totalLength = points.length;\n\n        for (let i = 0; i < totalLength; i++) {\n          // Get ease value and add delay based on loop iteration\n          let dotProgress = easeInOutCubic(dots.current / dots.total);\n          dotProgress = dotProgress + (dotProgress * (i / totalLength));\n\n          if (dotProgress > 1) {\n            dotProgress = 1;\n          }\n\n          // Move the point\n          points[i].x = dots.points[i].x * dotProgress;\n          points[i].y = dots.points[i].y * dotProgress;\n          points[i].z = dots.points[i].z * dotProgress;\n        }\n\n        dots.current++;\n        groupsRef.current.globeDots.geometry.verticesNeedUpdate = true;\n      }\n\n      if (dots.current >= (dots.total * 0.65) && globe.current <= globe.total) {\n        const globeProgress = easeOutCubic(globe.current / globe.total);\n        globeElementRef.current.material.opacity = alphas.globe * globeProgress;\n        globe.current++;\n      }\n    };\n\n    const addGlobeDots = () => {\n      const geometry = new Geometry();\n      const canvasSize = 8;\n      const halfSize = canvasSize / 2;\n      const textureCanvas = document.createElement('canvas');\n      textureCanvas.width = canvasSize;\n      textureCanvas.height = canvasSize;\n      const canvasContext = textureCanvas.getContext('2d');\n      canvasContext.beginPath();\n      canvasContext.arc(halfSize, halfSize, halfSize, 0, 2 * Math.PI);\n      canvasContext.fillStyle = colours.globeDots;\n      canvasContext.fill();\n\n      const texture = new Texture(textureCanvas);\n      texture.needsUpdate = true;\n\n      const material = new PointsMaterial({\n        map: texture,\n        size: globeRadius / 120,\n      });\n\n      const addDot = function ({ x, y }) {\n        const point = new Vector3(0, 0, 0);\n        geometry.vertices.push(point);\n        const result = returnSphericalCoordinates(x, y, mapSize, globeRadius);\n        animationsRef.current.dots.points.push(new Vector3(result.x, result.y, result.z));\n      };\n\n      for (let i = 0; i < globeData.points.length; i++) {\n        addDot(globeData.points[i]);\n      }\n\n      for (let country in globeData.countries) {\n        addDot(globeData.countries[country]);\n      }\n\n      groupsRef.current.globeDots = new Points(geometry, material);\n      groupsRef.current.globe.add(groupsRef.current.globeDots);\n    };\n\n    const addGlobe = () => {\n      const textureLoader = new TextureLoader();\n      textureLoader.setCrossOrigin(true);\n\n      const radius = globeRadius - (globeRadius * .02);\n      const segments = 64;\n      const rings = 64;\n\n      const canvasSize = 128;\n      const textureCanvas = document.createElement('canvas');\n      textureCanvas.width = canvasSize;\n      textureCanvas.height = canvasSize;\n      const canvasContext = textureCanvas.getContext('2d');\n      canvasContext.rect(0, 0, canvasSize, canvasSize);\n      const canvasGradient = canvasContext.createLinearGradient(0, 0, 0, canvasSize);\n\n      canvasGradient.addColorStop(0, globeColors[0]);\n      canvasGradient.addColorStop(.5, globeColors[1]);\n      canvasGradient.addColorStop(1, globeColors[2]);\n      canvasContext.fillStyle = canvasGradient;\n      canvasContext.fill();\n\n      const texture = new Texture(textureCanvas);\n      texture.needsUpdate = true;\n\n      const geometry = new SphereGeometry(radius, segments, rings);\n      const material = new MeshBasicMaterial({\n        map: texture,\n        transparent: true,\n        opacity: 0,\n      });\n\n      globeElementRef.current = new Mesh(geometry, material);\n      groupsRef.current.globe = new Group();\n      groupsRef.current.globe.rotation.y = -1;\n      groupsRef.current.globe.name = 'Globe';\n      groupsRef.current.globe.add(globeElementRef.current);\n      groupsRef.current.main.add(groupsRef.current.globe);\n\n      addGlobeDots();\n    };\n\n    const animate = () => {\n      animationFrameRef.current = requestAnimationFrame(animate);\n\n      if (groupsRef.current.globeDots) {\n        introAnimate();\n      }\n\n      cameraRef.current.controls.update();\n      rendererRef.current.render(sceneRef.current, cameraRef.current.object);\n    };\n\n    addGlobe();\n    animate();\n\n    return () => {\n      sceneRef.current.remove(globeElementRef.current);\n      cancelAnimationFrame(animationFrameRef.current);\n      clean(sceneRef.current);\n      rendererRef.current.dispose();\n      sceneRef.current.dispose();\n      cameraRef.current = null;\n      rendererRef.current.domElement = null;\n      rendererRef.current.forceContextLoss();\n    };\n  }, [alphas.globe, colours.globeDots, globeColors, globeRadius, mapSize]);\n\n  useEffect(() => {\n    const { width, height } = viewportSize;\n    cameraRef.current.object.aspect = width / (height / 2);\n    cameraRef.current.object.updateProjectionMatrix();\n    rendererRef.current.setSize(width, (height / 2));\n  }, [viewportSize]);\n\n  return (\n    <GlobeContainer status={status} {...props}>\n      <GlobeCanvas\n        viewportSize={viewportSize}\n        ref={canvasRef}\n        collapsed={collapsed}\n      />\n    </GlobeContainer>\n  );\n}\n\nGlobe.defaultProps = {\n  mapSize: {\n    width: 1024,\n    height: 512,\n  },\n  globeRadius: 200,\n  colours: {\n    globeDots: 'rgb(255, 255, 255)',\n  },\n  alphas: {\n    globe: 0.4,\n    lines: 0.5,\n  },\n};\n\nconst easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\nconst easeOutCubic = t => (--t) * t * t + 1;\n\nconst GlobeContainer = styled.div`\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  opacity: ${props => props.status === 'exiting' ? 0 : 1};\n  transition: opacity 0.4s ease;\n`;\n\nconst GlobeCanvas = styled.canvas.attrs(({ viewportSize, collapsed }) => ({\n  style: {\n    transform: collapsed\n      ? `translate3d(0, ${(viewportSize.height * 0.1)}px, 0)`\n      : `translate3d(0, ${(viewportSize.height / 4) + (viewportSize.height * 0.05)}px, 0)`,\n  }\n}))`\n  display: block;\n  transition: transform 0.6s ${props => props.theme.curveFastoutSlowin};\n\n  &:focus {\n    outline: none;\n  }\n`;\n\nexport default Globe;\n"],"sourceRoot":""}